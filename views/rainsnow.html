<html>
    <head>
        <title>
            간단한 비랑 눈
        </title>
        <link rel="stylesheet" type="text/css" href="/public/rainsnow.css" >
    </head>    
<body>
    <canvas id="weather" class="rain"></canvas>
    <button id="toggle-weather" class="btn">Toggle Weather</button>
    <button id="rainShaft" class="btn">rainShaft!</button>
    <button id="normal" class="btn">normal</button>
</body>
<script>


class weatherEffect {

  
  constructor() {

    this.canvas = document.getElementById("weather");
    this.ctx = this.canvas.getContext("2d");
    this.isRain = true;
    this.droplets = [];
    this.snowflakes = [];
    this.snowflakeTop = window.innerHeight;
    this.snowflakesOnGround = [];
    this.wind = 0;
    this.power = 50;
    this.weatherID = 0;
    this.backgroundImage = 0;
    this.backgroundImageLoaded = 0;
    
    
    // Set canvas size to be the size of the window
    this.ResizeWindow();

    const toggleBtn = document.getElementById("toggle-weather");
    const rainShaftBtn = document.getElementById("rainShaft");
    const normalBtn = document.getElementById("normal");


    // eventListener part start

    window.addEventListener('resize', () => this.ResizeWindow())
    normal.addEventListener("click", () => this.normal());
    toggleBtn.addEventListener("click", () => this.toggleWeather());
    rainShaftBtn.addEventListener("click", () => this.rainShaft());
    
    // eventListener part end
    
    this.addWeather();
    this.animate();

    this.backgroundImage = new Image();
    this.backgroundImage.src = 'public/images/blackcity.jpg';

    this.backgroundImage.onload = () => {
      this.backgroundImageLoaded = 1;
    }
  
  }

  // Create a loop to update the droplets/snowflakes
  animate = () => {
    requestAnimationFrame(this.animate);
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

     if(this.backgroundImageLoaded == 1){
       this.ctx.drawImage(this.backgroundImage,0,0,this.canvas.width, this.canvas.height);
     }
    

    
    this.wind += (Math.random())-0.5;
    
    if(this.wind > 20){
      this.wind = 20;
    }
    if(this.wind < -20){
      this.wind = -20;
    }

    if (this.isRain) {
      this.droplets.forEach((droplet) => {
        droplet.update(this.wind);
      });
    } else {
      this.snowflakes.forEach((snowflake) => {
        snowflake.update(this.wind);
      });

    }
  };

  ResizeWindow = () =>{
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
  }

  rainShaft = () => {
    
    this.power=10;
    clearInterval(this.weatherID);
    this.addWeather();

  };
  
  normal = () => {
    
    this.power=50;
    clearInterval(this.weatherID);
    this.addWeather();

  };

  toggleWeather = () =>{

    this.isRain = !this.isRain;
    this.canvas.classList.toggle("rain");
    this.canvas.classList.toggle("snow");

  }
  
  

  // Create a loop to add new droplets/snowflakes
  addWeather = () => {
    this.weatherID = setInterval(() => {
      if (this.isRain) {
        this.droplets.push(new Droplet(this.canvas, this.ctx,this));
      } else {
        this.snowflakes.push(new Snowflake(this.canvas, this.ctx,this));
      }
      // limit the number of droplets/snowflakes
      if (this.droplets.length > 10000) {
        this.droplets.shift();
      }
      if (this.snowflakes.length > 10000) {
        this.snowflakes.shift();
      }
    }, this.power);
  };


}


// 하늘에서 떨어지는 강수에 대한 정의
class precipitation {
  constructor(canvas,ctx,weatherEffectObj) {
    this.x = Math.random() * canvas.width;
    this.y = Math.random() * canvas.height/8;
    
    this.speed = Math.random() + 1;
    this.weight = Math.random()*0.5 + 0.1;

    this.canvas = canvas;
    this.ctx = ctx;
    this.collided = false;
    this.weatherEffectObj = weatherEffectObj;

  }

  checkCollision = (snowflake) =>{

    const snowflakes = this.weatherEffectObj.snowflakesOnGround;
    for (let i = 0; i < snowflakes.length; i++) {
      // check if the current snowflake is the same as the one passed in
      if (snowflakes[i] === snowflake) {
        continue;
      }
      // check if the current snowflake is in the same x position as the one passed in
      var distance = Math.sqrt(Math.pow(snowflake.x - (snowflakes[i].x), 2) + Math.pow(snowflake.y - snowflakes[i].y, 2));
      if (distance < snowflake.size + (snowflakes[i].size) ) {
        snowflake.y = snowflakes[i].y - ((snowflake.size + snowflakes[i].size)/8);
      }

      if(this.weatherEffectObj.snowflakeTop > snowflake.y ){
        this.weatherEffectObj.snowflakeTop = snowflake.y;
      }

    }

  }

  MoveWindEffect = (wind) =>{
    const canvas  = this.canvas;
    this.x += (wind * this.weight);
    if (this.x > canvas.width ) {
      this.oldx = 0;
      this.x = 0;
    }

    if (this.x < 0 ) {
      this.oldx = canvas.width;
      this.x = canvas.width;
    
  }

  }

  update = (wind) => {

    if(!this.collided){

      const canvas  = this.canvas;
      this.y += this.speed;

      if (this.y > canvas.height ) {
        this.groundfall(canvas);
        this.weight = 0.005;  //바람의 영향을 거의 안받도록 조정
      }

    }

    this.MoveWindEffect(wind);
    this.draw();
  }

}

// Create a Droplet class
class Droplet extends precipitation {
  constructor(canvas,ctx,weatherEffectObj) {
    super(canvas,ctx,weatherEffectObj);
    this.length = Math.random() * 8 + 5;

    this.setOldXY();
  }

  groundfall(){
    delete this;    
  }


  draw() {
    const ctx = this.ctx;
    //ctx.strokeStyle = "white"
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.beginPath();
    ctx.moveTo(this.oldx, this.oldy);
    ctx.lineTo(this.x, this.y + this.length);
    ctx.stroke();

    this.setOldXY();
  }
  
  setOldXY(){
    this.oldx = this.x;
    this.oldy = this.y;
  }

}

// Create a Snowflake class
class Snowflake extends precipitation {
  constructor(canvas,ctx,weatherEffectObj) {
    super(canvas,ctx,weatherEffectObj);
    this.size = Math.random() * 3 + 1;
    this.speed = Math.random() + 0.5;
    this.weight = Math.random()*0.1 + 0.5;
    
  }

  groundfall(canvas){


    this.y = canvas.height;
    this.collided = true;
    this.weatherEffectObj.snowflakesOnGround.push(this);
    this.checkCollision(this,this.weatherEffectObj);

  }



  draw() {

    const ctx = this.ctx;
    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI);
    ctx.fill();
  }

}

new weatherEffect();

</script>
</html>
